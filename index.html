<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ultimate 3D Game (v12 Camera Fix)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Roboto', sans-serif;
            background-color: #000;
        }
        canvas {
            display: block;
        }
        .ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0,0,0,0.6);
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
            max-height: 95vh;
            overflow-y: auto;
        }
        .ui-container button, .ui-container select, .ui-container input[type="text"] {
            display: block;
            width: 100%;
            margin-top: 8px;
            padding: 8px 12px;
            font-family: 'Roboto', sans-serif;
            cursor: pointer;
            border: 1px solid #555;
            background-color: #333;
            color: white;
            border-radius: 4px;
            box-sizing: border-box;
        }
        .ui-container label {
            display: inline-block;
            margin-top: 10px;
            font-size: 0.9em;
        }
        .ui-container input[type="range"] {
            width: 100%;
        }
        #coords, #speed-display, #destination-info {
            margin-bottom: 10px;
            font-size: 1.0em;
            background-color: rgba(0,0,0,0.3);
            padding: 5px;
            border-radius: 3px;
            white-space: pre;
            min-height: 1.2em;
        }
        #auto-drive-btn { display: none; background-color: #2a75d1; }

        #map-container {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 250px;
            height: 250px;
            border: 2px solid rgba(255, 255, 255, 0.7);
            background-color: rgba(0, 0, 0, 0.5);
        }
        #map-canvas { width: 100%; height: 100%; }

        .mobile-ui { display: none; }
        @media (pointer: coarse) {
            .mobile-ui { display: block; }
            #map-container { width: 150px; height: 150px; }
            .ui-container { max-width: 200px; }
        }

        #joystick-container {
            position: absolute;
            bottom: 80px; left: 20px;
            width: 120px; height: 120px;
        }
        #joystick-base {
            position: absolute;
            width: 120px; height: 120px;
            background: rgba(255,255,255,0.2);
            border-radius: 50%;
        }
        #joystick-handle {
            position: absolute;
            top: 40px; left: 40px;
            width: 40px; height: 40px;
            background: rgba(255,255,255,0.5);
            border-radius: 50%;
        }
        #run-button {
            position: absolute;
            bottom: 90px; right: 30px;
            width: 80px; height: 80px;
            background: rgba(255,255,255,0.3);
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2em;
            color: white;
            user-select: none;
        }
        #help-modal {
            display: none;
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            max-width: 80%;
            text-align: left;
            z-index: 100;
        }
        
        #chat-ui {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            max-width: 800px;
            box-sizing: border-box;
            background: rgba(0,0,0,0.5);
            border-radius: 5px;
            z-index: 10;
        }
        #chat-log {
            height: 6em;
            padding: 5px;
            overflow-y: scroll;
            color: white;
            font-size: 0.9em;
        }
        #chat-log p { margin: 0 0 2px 0; }
        #chat-form {
            display: flex;
            padding: 5px;
        }
        #chat-input {
            flex-grow: 1;
            background: rgba(0,0,0,0.5);
            color: white;
            border: 1px solid #555;
            border-radius: 3px;
            padding: 5px;
        }
        #chat-send {
            margin-left: 5px;
            background: #2a75d1;
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 3px;
        }
        .chat-bubble {
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 10px;
            font-size: 14px;
            text-align: center;
            pointer-events: none;
            /* 修正: 複数行表示とアニメーションのためのスタイル追加 */
            line-height: 1.4;
            max-width: 200px;
            word-break: break-all;
            transform-origin: 50% 100%;
        }
        /* 追加: ポップアップアニメーションの定義 */
        @keyframes popup-bubble {
            0% { transform: scale(0.5) translateY(10px); opacity: 0; }
            70% { transform: scale(1.1) translateY(0); opacity: 1; }
            100% { transform: scale(1) translateY(0); opacity: 1; }
        }
        .chat-bubble-animation {
            animation: popup-bubble 0.3s ease-out forwards;
        }
    </style>
</head>
<body>
    <div class="ui-container">
        <div id="coords">X: 0.00, Y: 0.00, Z: 0.00</div>
        <div id="speed-display">0 km/h | 0.0 m/s</div>
        <div id="destination-info"></div>
        <button id="change-camera-btn">視点切り替え (現在: 三人称)</button>
        <button id="change-character-btn">キャラクター変更</button>
        <button id="auto-drive-btn">自動運転開始</button>
        <button id="help-button">操作方法</button>
        <div><input type="checkbox" id="teleport-mode"><label for="teleport-mode">テレポートモード</label></div>
        <div><input type="checkbox" id="auto-drive-run"><label for="auto-drive-run">自動運転で走る</label></div>

        <label for="username-input">ユーザー名</label>
        <input type="text" id="username-input" value="Player">
        <label for="userid-input">ユーザーID</label>
        <input type="text" id="userid-input" value="001">

        <label for="npc-slider">NPCの数: <span id="npc-count">10</span></label>
        <input type="range" id="npc-slider" min="0" max="10000" value="10">

        <label for="chat-speed-slider">NPCチャット頻度: <span id="chat-speed-label">1</span> msg/s</label>
        <input type="range" id="chat-speed-slider" min="0" max="200" value="1">

        <label for="draw-distance-slider">描画距離(m): <span id="draw-distance-label">512</span></label>
        <input type="range" id="draw-distance-slider" min="1" max="1000" value="512">
        
        <label for="weather-select">天気</label>
        <select id="weather-select">
            <option value="sunny">晴れ</option>
            <option value="cloudy">くもり</option>
            <option value="rainy">雨</option>
            <option value="snowy">雪</option>
        </select>

        <label for="time-slider">時間: <span id="time-label">12:00</span></label>
        <input type="range" id="time-slider" min="0" max="23.99" value="12" step="0.01">
    </div>

    <div id="map-container">
        <canvas id="map-canvas" width="500" height="500"></canvas>
    </div>

    <div id="joystick-container" class="mobile-ui">
        <div id="joystick-base"></div>
        <div id="joystick-handle"></div>
    </div>
    <div id="run-button" class="mobile-ui">走る</div>
    
    <div id="help-modal">
        <h3>操作方法</h3>
        <p><b>移動:</b> W/A/S/D or 矢印キー or 左下ジョイスティック</p>
        <p><b>走る:</b> Shiftキー長押し or 右下「走る」ボタン長押し</p>
        <p><b>視点操作:</b> マウスドラッグ or 画面スワイプ</p>
        <p><b>テレポート:</b></p>
        <p>1. UIの「テレポートモード」にチェックを入れる</p>
        <p>2. 右上のマップで行きたい場所をクリック</p>
        <button id="close-help-button">閉じる</button>
    </div>

    <div id="chat-ui">
        <div id="chat-log"></div>
        <form id="chat-form">
            <input type="text" id="chat-input" placeholder="メッセージを入力...">
            <button id="chat-send" type="submit">送信</button>
        </form>
    </div>

    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    { "imports": {
            "three": "https://unpkg.com/three@0.157.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.157.0/examples/jsm/"
    } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import Stats from 'three/addons/libs/stats.module.js';
        import { Sky } from 'three/addons/objects/Sky.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        let scene, renderer, character, orbitControls, playerGroup, stats, composer, sky, sun, pmremGenerator, labelRenderer;
        let cameras = {}, currentCamera, currentCameraIndex = 0;
        const cameraTypes = ['Third Person', 'First Person', 'Free Look'];
        let keys = { w:false, a:false, s:false, d:false, Shift:false, ArrowUp:false, ArrowLeft:false, ArrowDown:false, ArrowRight:false };
        let characterDirection = new THREE.Vector3();
        let currentCharacterType = 0;
        
        let mapCanvas, mapCtx, mapBackgroundCanvas, mapBackgroundCtx;
        const MAP_WORLD_SIZE = 128;
        const PATHFINDING_GRID_SIZE = 50;
        let pathfindingGrid = [];
        let npcs = [], mapObjects = new THREE.Group(), buildings = [], streetLights = [];

        let weatherParticles, directionalLight, ambientLight, hemisphereLight;
        let destination = null, path = [], isAutoDriving = false;
        let autoDriveTargetIndex = 0;
        let currentSpeedMs = 0;
        const FRAME_RATE = 60;
        const WALK_SPEED_KMH = 4;
        const RUN_SPEED_KMH = 44.72;
        let isRunning = false;
        
        let isPointerDown = false;
        let pointerPosition = new THREE.Vector2();
        const cameraOffsetSpherical = new THREE.Spherical(8, Math.PI / 2.5, 0);
        const firstPersonEuler = new THREE.Euler(0, 0, 0, 'YXZ');
        let nextNpcChatTime = 0;

        const NPC_MESSAGES = [
            "こんにちは！", "やあ！", "いい天気だね。", "元気？", "調子はどう？", "また会ったね！", "今日は何を？", "どこへ行くの？", "良い一日を！", "こんばんは。",
            "この街は広いよね。", "空が綺麗だ。", "夜景もいいものだよ。", "たまに走ると気持ちいいよ。", "テレポートは便利だね。", "NPCの数は変えられるらしいよ。", "天気を変えてみるのも面白いかも。", "時間の流れって不思議だね。", "君のIDはなんだい？", "僕の名前はランダムだよ。", "高いところからの眺めは最高さ。", "操作にはもう慣れた？",
            "なんだか眠いな…", "今日は何をしようかな。", "考え事をしてたんだ。", "散歩はいい気分転換になる。", "あのビル、何階建てだろう？", "雲の形が面白い。", "風が気持ちいいね。", "少し休憩しようかな。", "時間はあっという間に過ぎるね。", "遠くを眺めるのが好きだ。", "静かな場所は落ち着くな。", "みんな忙しそうだ。", "何か面白いことないかな？", "明日は晴れるといいな。", "星が見えるかな。", "雨の音も悪くない。", "雪が降ると静かになるよね。", "影が伸びてきた。", "太陽が眩しい。", "ふと、空を見上げてしまう。", "ただ歩いているだけだよ。", "特に目的はないんだ。", "人生とはなんだろうね。", "君はどこから来たんだい？", "この街の歴史を知ってる？", "昔はここも違った景色だったのかな。", "未来はどうなるんだろう。", "テクノロジーの進歩はすごいね。", "たまには立ち止まるのも大事さ。", "自分のペースでいこう。", "急ぐことはないよ。", "道の先には何があるんだろう。", "交差点では注意しないとね。", "建物が綺麗に並んでいる。", "デザインが洗練されているな。", "シンプルなのも良いものだ。", "物思いにふけっていたよ。", "自分の影を追いかけてたんだ。", "なんだか懐かしい気分だ。", "一期一会だね。", "またどこかで会えるかな。", "じゃあ、またね。", "気をつけて！", "楽しんで！", "幸運を祈るよ。", "そろそろ行かないと。", "時間は有限だからね。", "一歩一歩、進んでいこう。", "上を向いて歩こう。", "下を向いていたら何も見えないよ。", "景色を楽しんでるかい？", "新しい発見があるかもしれない。", "角を曲がれば違う景色が。", "世界の広さを感じるよ。", "ここはどこで、私は誰だろう…", "哲学的な気分さ。", "なんてね、冗談だよ！", "人に話しかけるのは勇気がいるね。", "でも、話せてよかったよ。", "君のキャラクター、個性的だね。", "色々な人がいるから面白い。", "多様性は大事だ。", "みんな違って、みんないい。", "空の色が変わってきた。", "夕焼けは綺麗だね。", "夜の帳が下りてくる。", "一日の終わりだ。", "今日も一日お疲れ様。", "また明日も頑張ろう。", "夢の中で会えるかな。", "おやすみ。", "良い夢を。"
        ];

        function init() {
            scene = new THREE.Scene();

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            document.body.appendChild(renderer.domElement);
            
            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            labelRenderer.domElement.style.pointerEvents = 'none';
            document.body.appendChild(labelRenderer.domElement);

            pmremGenerator = new THREE.PMREMGenerator(renderer);

            stats = new Stats();
            document.body.appendChild(stats.dom);
            
            const initialFar = parseFloat(document.getElementById('draw-distance-slider').value);
            cameras.thirdPerson = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, initialFar);
            cameras.firstPerson = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, initialFar);
            cameras.freeLook = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, initialFar);
            cameras.freeLook.position.set(10, 10, 15);
            currentCamera = cameras.thirdPerson;
            scene.fog = new THREE.Fog(0x87ceeb, 20, initialFar * 0.9);

            orbitControls = new OrbitControls(cameras.freeLook, renderer.domElement);
            orbitControls.enabled = false;

            ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
            scene.add(ambientLight);
            hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.5);
            scene.add(hemisphereLight);
            directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(32, 64, 32);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.left = -MAP_WORLD_SIZE/2;
            directionalLight.shadow.camera.right = MAP_WORLD_SIZE/2;
            directionalLight.shadow.camera.top = MAP_WORLD_SIZE/2;
            directionalLight.shadow.camera.bottom = -MAP_WORLD_SIZE/2;
            scene.add(directionalLight);
            
            initSky();
            initPostProcessing();

            scene.add(mapObjects);
            
            playerGroup = new THREE.Group();
            character = createCharacter(currentCharacterType, false);
            playerGroup.userData = { name: "Player", id: "001" };
            playerGroup.add(character);
            scene.add(playerGroup);
            
            mapCanvas = document.getElementById('map-canvas');
            mapCtx = mapCanvas.getContext('2d');
            mapBackgroundCanvas = document.createElement('canvas');
            mapBackgroundCanvas.width = mapCanvas.width;
            mapBackgroundCanvas.height = mapCanvas.height;
            mapBackgroundCtx = mapBackgroundCanvas.getContext('2d');

            setupEventListeners();
            
            createCityMap();
            drawMapBackground();
            updateTime(parseFloat(document.getElementById('time-slider').value));

            updateNpcCount();
            
            animate();
        }

        function initSky() {
            sky = new Sky();
            sky.scale.setScalar(MAP_WORLD_SIZE * 2);
            scene.add(sky);
            sun = new THREE.Vector3();
        }

        function initPostProcessing() {
            composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, currentCamera);
            composer.addPass(renderPass);

            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.5, 0.5, 0.85);
            bloomPass.threshold = 0.8;
            composer.addPass(bloomPass);
        }

        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', (e) => { keys[e.key] = true; stopAutoDrive(); });
            document.addEventListener('keyup', (e) => { keys[e.key] = false; });
            document.getElementById('change-camera-btn').addEventListener('click', changeCamera);
            document.getElementById('change-character-btn').addEventListener('click', () => changeCharacter(true));
            document.getElementById('auto-drive-btn').addEventListener('click', startAutoDrive);
            document.getElementById('help-button').addEventListener('click', () => { document.getElementById('help-modal').style.display = 'block'; });
            document.getElementById('close-help-button').addEventListener('click', () => { document.getElementById('help-modal').style.display = 'none'; });
            
            document.getElementById('username-input').addEventListener('input', (e) => { playerGroup.userData.name = e.target.value; });
            document.getElementById('userid-input').addEventListener('input', (e) => { playerGroup.userData.id = e.target.value; });

            document.getElementById('chat-form').addEventListener('submit', (e) => {
                e.preventDefault();
                const input = document.getElementById('chat-input');
                if (input.value.trim() !== '') {
                    addChatMessage(playerGroup, input.value);
                    input.value = '';
                }
            });

            const npcSlider = document.getElementById('npc-slider');
            npcSlider.addEventListener('input', () => { document.getElementById('npc-count').textContent = npcSlider.value; });
            npcSlider.addEventListener('change', updateNpcCount);

            const chatSpeedSlider = document.getElementById('chat-speed-slider');
            chatSpeedSlider.addEventListener('input', (e) => {
                document.getElementById('chat-speed-label').textContent = `${e.target.value} msg/s`;
            });

            const drawDistanceSlider = document.getElementById('draw-distance-slider');
            drawDistanceSlider.addEventListener('input', (e) => {
                const distance = parseFloat(e.target.value);
                document.getElementById('draw-distance-label').textContent = distance.toFixed(0);
                cameras.thirdPerson.far = distance;
                cameras.firstPerson.far = distance;
                cameras.freeLook.far = distance;
                cameras.thirdPerson.updateProjectionMatrix();
                cameras.firstPerson.updateProjectionMatrix();
                cameras.freeLook.updateProjectionMatrix();
                scene.fog.far = distance * 0.9;
            });

            document.getElementById('weather-select').addEventListener('change', (e) => changeWeather(e.target.value));
            document.getElementById('time-slider').addEventListener('input', (e) => updateTime(parseFloat(e.target.value)));

            mapCanvas.addEventListener('click', handleMapClick);
            setupMobileControls();
            
            renderer.domElement.addEventListener('pointerdown', onPointerDown);
            renderer.domElement.addEventListener('pointermove', onPointerMove);
            renderer.domElement.addEventListener('pointerup', onPointerUp);
        }

        function createCityMap() {
            initPathfindingGrid();
            buildings = [];
            streetLights = [];
            
            const ground = new THREE.Mesh(new THREE.PlaneGeometry(MAP_WORLD_SIZE, MAP_WORLD_SIZE), new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.8 }));
            ground.rotation.x = -Math.PI / 2; ground.receiveShadow = true; mapObjects.add(ground);
            
            const roadW = 8; 
            const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.9 });
            const roadInterval = 40;
            
            for (let i = -1; i <= 1; i++) {
                const roadX = new THREE.Mesh(new THREE.PlaneGeometry(roadW, MAP_WORLD_SIZE), roadMaterial);
                roadX.rotation.x = -Math.PI / 2; roadX.position.set(i * roadInterval, 0.01, 0); roadX.receiveShadow = true; mapObjects.add(roadX);
                markPathfindingGrid(roadX.position, roadW/2, MAP_WORLD_SIZE/2, 2);
                if (i !== 0) {
                    for (let z = -MAP_WORLD_SIZE/2 + 10; z < MAP_WORLD_SIZE/2; z += 20) {
                        const light1 = createStreetLight();
                        light1.position.set(i * roadInterval + roadW/2 + 1, 0, z);
                        mapObjects.add(light1);
                        streetLights.push(light1.children[2]);
                    }
                }
            }

            for (let i = 0; i < 150; i++) {
                const x = (Math.random() - 0.5) * MAP_WORLD_SIZE * 0.98;
                const z = (Math.random() - 0.5) * MAP_WORLD_SIZE * 0.98;
                if (Math.abs(x % roadInterval) < roadW/2+4 || Math.abs(z % roadInterval) < roadW/2+4) continue;

                const height = Math.random() * 20 + 8;
                const bSize = Math.random()*5+4;
                const building = new THREE.Mesh(
                    new THREE.BoxGeometry(bSize, height, bSize),
                    new THREE.MeshStandardMaterial({ 
                        color: new THREE.Color(Math.random()*0.2+0.2,Math.random()*0.2+0.2,Math.random()*0.2+0.2),
                        roughness: 0.5 + Math.random() * 0.4, 
                        metalness: Math.random() * 0.5
                    })
                );
                building.position.set(x, height/2, z);
                building.castShadow = true;
                building.receiveShadow = true;
                mapObjects.add(building);
                buildings.push(building);
                markPathfindingGrid(building.position, bSize/2, bSize/2, 1);
            }
        }
        
        function createStreetLight() {
            const group = new THREE.Group();
            const postMat = new THREE.MeshStandardMaterial({color: 0x555555, roughness: 0.8, metalness: 0.2});
            const post = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 4, 8), postMat);
            post.position.y = 2;
            post.castShadow = true;
            const arm = new THREE.Mesh(new THREE.BoxGeometry(1, 0.1, 0.1), postMat);
            arm.position.set(0.5, 4, 0);
            arm.castShadow = true;
            const light = new THREE.PointLight(0xffddaa, 0, 15, 2);
            light.position.set(1, 3.8, 0);
            light.castShadow = true;
            group.add(post, arm, light);
            return group;
        }

        function initPathfindingGrid() {
            pathfindingGrid = [];
            for(let i=0; i<PATHFINDING_GRID_SIZE; i++) {
                pathfindingGrid[i] = new Array(PATHFINDING_GRID_SIZE).fill(0);
            }
        }
        function markPathfindingGrid(center, width, depth, type) {
            const scale = MAP_WORLD_SIZE / PATHFINDING_GRID_SIZE;
            const cX = Math.floor((center.x / MAP_WORLD_SIZE + 0.5) * PATHFINDING_GRID_SIZE);
            const cZ = Math.floor((center.z / MAP_WORLD_SIZE + 0.5) * PATHFINDING_GRID_SIZE);
            const halfW = Math.ceil(width / scale);
            const halfD = Math.ceil(depth / scale);
            for(let i = Math.max(0, cX - halfW); i < Math.min(PATHFINDING_GRID_SIZE, cX + halfW); i++) {
                for(let j = Math.max(0, cZ - halfD); j < Math.min(PATHFINDING_GRID_SIZE, cZ + halfD); j++) {
                    if (pathfindingGrid[i][j] === 0) pathfindingGrid[i][j] = type;
                }
            }
        }

        function findPath(startVec, endVec) {
            const startNode = worldToGrid(startVec);
            const endNode = worldToGrid(endVec);
            if (!isNodePassable(startNode) || !isNodePassable(endNode)) return [];
            let openSet = [startNode];
            let cameFrom = {};
            let gScore = { [`${startNode.x},${startNode.y}`]: 0 };
            let fScore = { [`${startNode.x},${startNode.y}`]: heuristic(startNode, endNode) };
            while (openSet.length > 0) {
                openSet.sort((a,b) => fScore[`${a.x},${a.y}`] - fScore[`${b.x},${b.y}`]);
                let current = openSet.shift();
                if (current.x === endNode.x && current.y === endNode.y) return reconstructPath(cameFrom, current);
                getNeighbors(current).forEach(neighbor => {
                    let tentativeGScore = gScore[`${current.x},${current.y}`] + 1;
                    let neighborKey = `${neighbor.x},${neighbor.y}`;
                    if (!gScore.hasOwnProperty(neighborKey) || tentativeGScore < gScore[neighborKey]) {
                        cameFrom[neighborKey] = current;
                        gScore[neighborKey] = tentativeGScore;
                        fScore[neighborKey] = gScore[neighborKey] + heuristic(neighbor, endNode);
                        if (!openSet.some(node => node.x === neighbor.x && node.y === neighbor.y)) {
                            openSet.push(neighbor);
                        }
                    }
                });
            }
            return [];
        }

        function isNodePassable(node) {
            if (node.x < 0 || node.x >= PATHFINDING_GRID_SIZE || node.y < 0 || node.y >= PATHFINDING_GRID_SIZE) return false;
            return pathfindingGrid[node.x][node.y] !== 1;
        }
        function heuristic(a, b) { return Math.abs(a.x - b.x) + Math.abs(a.y - b.y); }
        function getNeighbors(node) {
            let neighbors = [];
            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    if (x === 0 && y === 0) continue;
                    const newX = node.x + x;
                    const newY = node.y + y;
                    if (isNodePassable({x: newX, y: newY})) {
                        neighbors.push({x: newX, y: newY});
                    }
                }
            }
            return neighbors;
        }
        function reconstructPath(cameFrom, current) {
            const totalPath = [gridToWorld(current)];
            let currentKey = `${current.x},${current.y}`;
            while (cameFrom[currentKey]) {
                current = cameFrom[currentKey];
                currentKey = `${current.x},${current.y}`;
                totalPath.unshift(gridToWorld(current));
            }
            return totalPath;
        }
        function worldToGrid(worldVec) {
            const x = Math.floor((worldVec.x / MAP_WORLD_SIZE + 0.5) * PATHFINDING_GRID_SIZE);
            const y = Math.floor((worldVec.z / MAP_WORLD_SIZE + 0.5) * PATHFINDING_GRID_SIZE);
            return {x, y};
        }
        function gridToWorld(gridNode) {
            return new THREE.Vector3(
                (gridNode.x / PATHFINDING_GRID_SIZE - 0.5) * MAP_WORLD_SIZE, 0,
                (gridNode.y / PATHFINDING_GRID_SIZE - 0.5) * MAP_WORLD_SIZE
            );
        }

        function createCharacter(type, isNpc = false) {
            const group = new THREE.Group();
            const shadowCaster = (obj) => { 
                if (!isNpc) obj.castShadow = true;
                obj.receiveShadow = true;
            };
            let body, head;
            const colors = [0x3399ff, 0xcccccc, 0x966c4a, 0x4a86e8, 0x6aa84f, 0xe06666];
            switch(type) {
                case 0:
                    body = new THREE.Mesh(new THREE.DodecahedronGeometry(0.7), new THREE.MeshStandardMaterial({ color: colors[type] }));
                    body.position.y = 0.7; shadowCaster(body); group.add(body); break;
                case 1:
                    body = new THREE.Mesh(new THREE.BoxGeometry(1, 1.2, 0.6), new THREE.MeshStandardMaterial({ color: colors[type] }));
                    body.position.y = 0.8; shadowCaster(body);
                    head = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.7, 0.7), new THREE.MeshStandardMaterial({ color: 0xaaaaaa }));
                    head.position.y = 1.75; shadowCaster(head); group.add(body, head); break;
                case 2:
                    body = new THREE.Mesh(new THREE.IcosahedronGeometry(0.8), new THREE.MeshStandardMaterial({ color: colors[type] }));
                    body.position.y = 0.8; shadowCaster(body); group.add(body); break;
                case 3: case 4: case 5:
                    const skin = 0xffd3b4;
                    body = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 1.0, 8), new THREE.MeshStandardMaterial({ color: colors[type] }));
                    body.position.y = 0.8; shadowCaster(body);
                    head = new THREE.Mesh(new THREE.SphereGeometry(0.35), new THREE.MeshStandardMaterial({ color: skin }));
                    head.position.y = 1.6; shadowCaster(head);
                    const arm1 = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.8, 0.2), new THREE.MeshStandardMaterial({ color: skin }));
                    arm1.position.set(-0.5, 1.0, 0); shadowCaster(arm1);
                    const arm2 = arm1.clone(); arm2.position.x = 0.5;
                    const leg1 = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.8, 0.25), new THREE.MeshStandardMaterial({ color: 0x333333 }));
                    leg1.position.set(-0.2, 0.4, 0); shadowCaster(leg1);
                    const leg2 = leg1.clone(); leg2.position.x = 0.2;
                    group.add(body, head, arm1, arm2, leg1, leg2);
                    break;
            }
            const chatDiv = document.createElement('div');
            chatDiv.className = 'chat-bubble';
            const chatLabel = new CSS2DObject(chatDiv);
            chatLabel.position.set(0, 2.2, 0);
            chatLabel.visible = false;
            group.add(chatLabel);
            return group;
        }
        function changeCharacter(isPlayer) {
            if (isPlayer) {
                const oldPosition = playerGroup.position.clone();
                const oldRotation = playerGroup.quaternion.clone();
                scene.remove(playerGroup);
                playerGroup = new THREE.Group();
                currentCharacterType = (currentCharacterType + 1) % 6;
                character = createCharacter(currentCharacterType, false);
                playerGroup.add(character);
                playerGroup.userData = { name: document.getElementById('username-input').value, id: document.getElementById('userid-input').value };
                playerGroup.position.copy(oldPosition);
                playerGroup.quaternion.copy(oldRotation);
                scene.add(playerGroup);
            } else {
                 return createCharacter(Math.floor(Math.random() * 6), true);
            }
        }

        function updateNpcCount() {
            const newCount = parseInt(document.getElementById('npc-slider').value);
            while (npcs.length < newCount) {
                const npc = changeCharacter(false);
                npc.userData = { name: "NPC " + (npcs.length + 1), id: 1000 + npcs.length + 1 };
                resetNpcPosition(npc);
                npc.targetPosition = new THREE.Vector3();
                resetNpcTarget(npc);
                npcs.push(npc);
                scene.add(npc);
            }
            while (npcs.length > newCount) {
                const npcToRemove = npcs.pop();
                scene.remove(npcToRemove);
            }
        }
        function resetNpcPosition(npc) {
             npc.position.set((Math.random() - 0.5) * MAP_WORLD_SIZE * 0.95, 0, (Math.random() - 0.5) * MAP_WORLD_SIZE * 0.95);
        }
        function resetNpcTarget(npc) {
            npc.targetPosition.set((Math.random() - 0.5) * MAP_WORLD_SIZE * 0.95, 0, (Math.random() - 0.5) * MAP_WORLD_SIZE * 0.95);
        }
        function moveNpcs() {
            const playerPos = playerGroup.position;
            const updateDistanceSq = 50 * 50;
            npcs.forEach(npc => {
                if (npc.position.distanceToSquared(playerPos) > updateDistanceSq) return;
                const distanceToTarget = npc.position.distanceTo(npc.targetPosition);
                if (distanceToTarget < 2) resetNpcTarget(npc);
                const direction = npc.targetPosition.clone().sub(npc.position).normalize();
                npc.position.add(direction.multiplyScalar(0.02));
                npc.rotation.y = Math.atan2(direction.x, direction.z);
            });
        }

        /**
         * 修正: この関数は全体的に修正されました。
         * 1. プレイヤーのチャットが頭上に表示されるように検索方法を変更しました。
         * 2. 連続したチャットが複数行で表示されるようにしました。
         * 3. 表示時にポップアップアニメーションが再生されるようにしました。
         */
        function addChatMessage(characterObject, message) {
            const log = document.getElementById('chat-log');
            const p = document.createElement('p');
            p.textContent = `[${characterObject.userData.name}]: ${message}`;
            log.appendChild(p);
            log.scrollTop = log.scrollHeight;

            // 修正点1: getObjectByPropertyを使い、ネストされたオブジェクト内のラベルも検索できるようにする
            const label = characterObject.getObjectByProperty('isCSS2DObject', true);

            if (label) {
                // 修正点2: 複数行チャットを管理
                if (!label.messages) {
                    label.messages = [];
                }
                label.messages.push(message);
                // 表示するメッセージの最大数を3に制限
                if (label.messages.length > 3) {
                    label.messages.shift();
                }
                label.element.innerHTML = label.messages.join('<br>');

                label.visible = true;

                // 修正点3: ポップアップアニメーションをトリガー
                // 一度クラスを削除し、requestAnimationFrameを使って次の描画サイクルでクラスを追加することで、
                // 毎回アニメーションが再生されるようにする
                label.element.classList.remove('chat-bubble-animation');
                requestAnimationFrame(() => {
                    label.element.classList.add('chat-bubble-animation');
                });


                if (label.timeout) clearTimeout(label.timeout);
                // タイムアウトで非表示にし、メッセージ配列と表示内容、アニメーションクラスをクリアする
                label.timeout = setTimeout(() => {
                    label.visible = false;
                    label.messages = [];
                    label.element.innerHTML = '';
                    label.element.classList.remove('chat-bubble-animation');
                }, 5000);
            }
        }

        function handleNpcChat(time) {
            const chatSpeed = parseFloat(document.getElementById('chat-speed-slider').value);
            if (chatSpeed === 0 || npcs.length === 0 || time < nextNpcChatTime) return;
            const interval = 1000 / chatSpeed;
            nextNpcChatTime = time + Math.random() * interval * 2;
            const randomNpc = npcs[Math.floor(Math.random() * npcs.length)];
            const randomMessage = NPC_MESSAGES[Math.floor(Math.random() * NPC_MESSAGES.length)];
            addChatMessage(randomNpc, randomMessage);
        }

        function changeCamera() {
            currentCameraIndex = (currentCameraIndex + 1) % cameraTypes.length;
            const cameraName = cameraTypes[currentCameraIndex];
            orbitControls.enabled = (cameraName === 'Free Look');
            currentCamera = (cameraName === 'Third Person') ? cameras.thirdPerson : (cameraName === 'First Person') ? cameras.firstPerson : cameras.freeLook;
            composer.passes[0].camera = currentCamera;
            document.getElementById('change-camera-btn').textContent = `視点切り替え (現在: ${cameraName})`;
            onWindowResize();
        }
        function handleMapClick(event) {
            const rect = mapCanvas.getBoundingClientRect();
            const scaleX = mapCanvas.width / rect.width;
            const scaleY = mapCanvas.height / rect.height;
            const canvasX = (event.clientX - rect.left) * scaleX;
            const canvasY = (event.clientY - rect.top) * scaleY;
            const worldX = (canvasX / mapCanvas.width - 0.5) * MAP_WORLD_SIZE;
            const worldZ = (canvasY / mapCanvas.height - 0.5) * MAP_WORLD_SIZE;
            
            if (document.getElementById('teleport-mode').checked) {
                playerGroup.position.set(worldX, 0, worldZ);
                stopAutoDrive(); path = []; destination = null;
                document.getElementById('destination-info').textContent = '';
            } else {
                destination = new THREE.Vector3(worldX, 0, worldZ);
                stopAutoDrive();
                path = findPath(playerGroup.position, destination);
                document.getElementById('auto-drive-btn').style.display = path.length > 0 ? 'block' : 'none';
                updateDestinationInfo();
            }
        }
        function startAutoDrive() {
            if (path.length > 0) {
                isAutoDriving = true;
                autoDriveTargetIndex = 1;
                document.getElementById('auto-drive-btn').style.display = 'none';
            }
        }
        function stopAutoDrive() {
            isAutoDriving = false;
            if (destination && path.length > 0) document.getElementById('auto-drive-btn').style.display = 'block';
        }
        
        function updateDestinationInfo() {
            if (!path || path.length === 0) {
                document.getElementById('destination-info').textContent = '';
                return;
            }
            let distance = 0;
            for (let i = 0; i < path.length - 1; i++) {
                distance += path[i].distanceTo(path[i+1]);
            }
            const isAutoRun = document.getElementById('auto-drive-run').checked;
            const speedKmh = isAutoRun ? RUN_SPEED_KMH : WALK_SPEED_KMH;
            const speedMs = (speedKmh * 1000) / 3600;
            const timeSec = distance / speedMs;
            let timeString;
            if (timeSec < 60) {
                timeString = `${Math.round(timeSec)}秒`;
            } else if (timeSec < 3600) {
                timeString = `${Math.floor(timeSec / 60)}分 ${Math.round(timeSec % 60)}秒`;
            } else {
                timeString = `${Math.floor(timeSec / 3600)}時間 ${Math.floor((timeSec % 3600) / 60)}分`;
            }
            document.getElementById('destination-info').textContent = `距離: ${distance.toFixed(0)}m, 到着予測: ${timeString}`;
        }

        function updateTime(hour) {
            const timeLabel = document.getElementById('time-label');
            const h = Math.floor(hour);
            const m = Math.floor((hour - h) * 60);
            timeLabel.textContent = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
            const uniforms = sky.material.uniforms;
            const isNight = hour >= 17 || hour < 6;
            const phi = THREE.MathUtils.degToRad(90 - (hour - 6) * 15);
            sun.setFromSphericalCoords(1, phi, Math.PI);
            uniforms['sunPosition'].value.copy(sun);
            if (isNight) {
                uniforms['turbidity'].value = 1; uniforms['rayleigh'].value = 0.1;
                directionalLight.intensity = 0; ambientLight.intensity = 0.05; hemisphereLight.intensity = 0.1;
            } else {
                const day_t = (hour - 6) / 11;
                const noon_factor = 1 - Math.abs(day_t - 0.5) * 2;
                uniforms['turbidity'].value = 3 + (1 - noon_factor) * 7;
                uniforms['rayleigh'].value = 0.5 + noon_factor * 2.5;
                directionalLight.intensity = 0.8 + noon_factor * 0.7;
                ambientLight.intensity = 0.2 + noon_factor * 0.4;
                hemisphereLight.intensity = 0.2 + noon_factor * 0.3;
            }
            directionalLight.position.copy(sun).multiplyScalar(50);
            scene.environment = pmremGenerator.fromScene(sky).texture;
            streetLights.forEach(light => { light.intensity = isNight ? 2 : 0; });
            buildings.forEach(building => {
                building.material.emissive.setHex(isNight ? 0x996600 : 0x000000);
            });
        }
        function changeWeather(weather) {
            if (weatherParticles) {
                scene.remove(weatherParticles);
                weatherParticles.geometry.dispose();
                weatherParticles.material.dispose();
                weatherParticles = null;
            }
            updateTime(parseFloat(document.getElementById('time-slider').value));
            const uniforms = sky.material.uniforms;
            if(weather === 'cloudy') {
                uniforms['turbidity'].value = 20; uniforms['rayleigh'].value = 1.5;
            } else if (weather === 'rainy' || weather === 'snowy') {
                uniforms['turbidity'].value = 20; uniforms['rayleigh'].value = 0.5;
                const count = weather === 'rainy' ? 3000 : 1500;
                const positions = new Float32Array(count * 3);
                const velocities = new Float32Array(count * 3);
                const geometry = new THREE.BufferGeometry();
                for(let i=0; i<count*3; i+=3) {
                    velocities[i] = (weather === 'snowy') ? (Math.random() - 0.5) * 0.05 : 0;
                    velocities[i+1] = weather === 'rainy' ? -Math.random() * 0.8 - 0.5 : -Math.random() * 0.05 - 0.02;
                }
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
                const material = new THREE.PointsMaterial({
                    color: (weather === 'rainy') ? 0xaaaaee : 0xffffff,
                    size: (weather === 'rainy') ? 0.05 : 0.15,
                    transparent: true, opacity: 0.6, sizeAttenuation: true
                });
                weatherParticles = new THREE.Points(geometry, material);
                scene.add(weatherParticles);
            }
        }
        
        function drawMapBackground() {
            mapBackgroundCtx.clearRect(0, 0, mapBackgroundCanvas.width, mapBackgroundCanvas.height);
            mapBackgroundCtx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            mapBackgroundCtx.fillRect(0, 0, mapBackgroundCanvas.width, mapBackgroundCanvas.height);
            const cellW = mapBackgroundCanvas.width / PATHFINDING_GRID_SIZE;
            for(let i=0; i<PATHFINDING_GRID_SIZE; i++){
                for(let j=0; j<PATHFINDING_GRID_SIZE; j++){
                    switch(pathfindingGrid[i][j]){
                        case 1: mapBackgroundCtx.fillStyle = 'rgba(100,0,0,0.5)'; break;
                        case 2: mapBackgroundCtx.fillStyle = 'rgba(50,50,50,0.5)'; break;
                        default: mapBackgroundCtx.fillStyle = 'transparent';
                    }
                    mapBackgroundCtx.fillRect(i*cellW, j*cellW, cellW, cellW);
                }
            }
        }
        function drawMap() {
            mapCtx.drawImage(mapBackgroundCanvas, 0, 0);
            const toMapCoords = (pos) => ({
                x: (pos.x / MAP_WORLD_SIZE + 0.5) * mapCanvas.width,
                z: (pos.z / MAP_WORLD_SIZE + 0.5) * mapCanvas.height
            });
            if (path.length > 1) {
                mapCtx.strokeStyle = isAutoDriving ? 'rgba(0, 150, 255, 0.8)' : 'rgba(255, 0, 0, 0.8)';
                mapCtx.lineWidth = 3; mapCtx.beginPath();
                let p = toMapCoords(path[0]); mapCtx.moveTo(p.x, p.z);
                for(let i=1; i<path.length; i++) {
                    p = toMapCoords(path[i]); mapCtx.lineTo(p.x, p.z);
                }
                mapCtx.stroke();
            }
            mapCtx.fillStyle = 'rgba(150, 150, 150, 0.7)';
            npcs.forEach(npc => {
                const p = toMapCoords(npc.position);
                mapCtx.fillRect(p.x - 1, p.z - 1, 2, 2);
            });
            if (destination) {
                mapCtx.fillStyle = 'red';
                const d = toMapCoords(destination);
                mapCtx.beginPath(); mapCtx.arc(d.x, d.z, 6, 0, Math.PI * 2); mapCtx.fill();
            }
            mapCtx.fillStyle = 'white';
            const p = toMapCoords(playerGroup.position);
            mapCtx.beginPath(); mapCtx.arc(p.x, p.z, 5, 0, Math.PI * 2); mapCtx.fill();
        }
        function onWindowResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            currentCamera.aspect = width / height;
            currentCamera.updateProjectionMatrix();
            renderer.setSize(width, height);
            composer.setSize(width, height);
            labelRenderer.setSize(width, height);
        }
        function setupMobileControls() {
            const joystick = document.getElementById('joystick-handle');
            const base = document.getElementById('joystick-base');
            const runButton = document.getElementById('run-button');
            const radius = base.offsetWidth / 2;
            let joyX = 0, joyY = 0;
            const moveJoystick = (touch) => {
                const rect = base.getBoundingClientRect();
                const x = touch.clientX - rect.left - radius;
                const y = touch.clientY - rect.top - radius;
                const distance = Math.min(radius, Math.hypot(x, y));
                const angle = Math.atan2(y, x);
                joyX = Math.cos(angle) * distance;
                joyY = Math.sin(angle) * distance;
                joystick.style.transform = `translate(${joyX}px, ${joyY}px)`;
                const normalizedY = y / radius; const normalizedX = x / radius;
                keys.w = normalizedY < -0.3; keys.s = normalizedY > 0.3;
                keys.a = normalizedX < -0.3; keys.d = normalizedX > 0.3;
            };
            const touchEnd = () => {
                joystick.style.transform = `translate(0px, 0px)`;
                keys.w = keys.a = keys.s = keys.d = false;
            };
            base.addEventListener('touchstart', (e) => { e.preventDefault(); moveJoystick(e.touches[0]); }, { passive: false });
            base.addEventListener('touchmove', (e) => { e.preventDefault(); moveJoystick(e.touches[0]); }, { passive: false });
            base.addEventListener('touchend', touchEnd);
            base.addEventListener('touchcancel', touchEnd);
            runButton.addEventListener('touchstart', (e) => { e.preventDefault(); isRunning = true; }, { passive: false });
            runButton.addEventListener('touchend', (e) => { e.preventDefault(); isRunning = false; }, { passive: false });
        }
        
        function onPointerDown(event) {
            if (document.activeElement.tagName === 'INPUT') return;
            if (event.target.tagName === 'CANVAS') {
                isPointerDown = true;
                pointerPosition.x = event.clientX;
                pointerPosition.y = event.clientY;
            }
        }
        function onPointerMove(event) {
            if (!isPointerDown || currentCameraIndex === 2) return;
            const deltaX = event.clientX - pointerPosition.x;
            const deltaY = event.clientY - pointerPosition.y;

            if (currentCameraIndex === 1) { // ★一人称視点
                playerGroup.rotation.y -= deltaX * 0.002;
                // 上下スクロールは無効化
            } else { // ★三人称視点
                cameraOffsetSpherical.theta -= deltaX * 0.005;
                cameraOffsetSpherical.phi -= deltaY * 0.005;
                cameraOffsetSpherical.phi = Math.max(0.1, Math.min(Math.PI - 0.5, cameraOffsetSpherical.phi));
            }
            pointerPosition.x = event.clientX;
            pointerPosition.y = event.clientY;
        }
        function onPointerUp() { isPointerDown = false; }
        
        function animate(time) {
            requestAnimationFrame(animate);
            stats.begin();

            isRunning = keys['Shift'] || isRunning;
            const isMoving = (keys.w||keys.s||keys.a||keys.d||keys.ArrowUp||keys.ArrowDown||keys.ArrowLeft||keys.ArrowRight) || isAutoDriving;
            
            const autoRun = document.getElementById('auto-drive-run').checked;
            let targetSpeedKmh = 0;
            if(isAutoDriving) targetSpeedKmh = autoRun ? RUN_SPEED_KMH : WALK_SPEED_KMH;
            else if(isMoving) targetSpeedKmh = isRunning ? RUN_SPEED_KMH : WALK_SPEED_KMH;

            currentSpeedMs = (targetSpeedKmh * 1000) / 3600;
            const moveDistance = currentSpeedMs / FRAME_RATE;
            
            characterDirection.set(0,0,0);
            if (isAutoDriving) {
                if(autoDriveTargetIndex >= path.length) {
                    stopAutoDrive();
                } else {
                    const targetPoint = path[autoDriveTargetIndex];
                    if(playerGroup.position.distanceTo(targetPoint) < 1) autoDriveTargetIndex++;
                    if(autoDriveTargetIndex < path.length) characterDirection.subVectors(path[autoDriveTargetIndex], playerGroup.position).normalize();
                }
            } else {
                if (keys.w || keys.ArrowUp) characterDirection.z = -1;
                if (keys.s || keys.ArrowDown) characterDirection.z = 1;
                if (keys.a || keys.ArrowLeft) characterDirection.x = -1;
                if (keys.d || keys.ArrowRight) characterDirection.x = 1;
            }
            
            if(characterDirection.lengthSq() > 0) {
                const moveVector = characterDirection.normalize();
                
                if(!isAutoDriving) {
                    const targetAngle = playerGroup.rotation.y + Math.atan2(characterDirection.x, characterDirection.z);
                    moveVector.set(Math.sin(targetAngle), 0, Math.cos(targetAngle));
                } else {
                    const targetAngle = Math.atan2(characterDirection.x, characterDirection.z);
                    const targetQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), targetAngle);
                    playerGroup.quaternion.slerp(targetQuat, 0.1);
                }
                
                const newPosition = playerGroup.position.clone().add(moveVector.multiplyScalar(moveDistance));
                const halfMap = MAP_WORLD_SIZE / 2 - 1;
                newPosition.x = Math.max(-halfMap, Math.min(halfMap, newPosition.x));
                newPosition.z = Math.max(-halfMap, Math.min(halfMap, newPosition.z));
                playerGroup.position.copy(newPosition);
            }
            
            if(currentCamera === cameras.thirdPerson) {
                const offset = new THREE.Vector3().setFromSpherical(cameraOffsetSpherical);
                currentCamera.position.copy(playerGroup.position).add(offset);
                currentCamera.lookAt(playerGroup.position);
            } else if (currentCamera === cameras.firstPerson) {
                currentCamera.position.copy(playerGroup.position).add(new THREE.Vector3(0, 1.5, 0));
                currentCamera.quaternion.copy(playerGroup.quaternion);
            } else {
                 orbitControls.update();
            }

            moveNpcs();
            handleNpcChat(time);
            if(weatherParticles) {
                weatherParticles.position.copy(playerGroup.position);
                const positions = weatherParticles.geometry.attributes.position.array;
                const velocities = weatherParticles.geometry.attributes.velocity.array;
                for(let i=0; i<positions.length; i+=3) {
                    positions[i] += velocities[i];
                    positions[i+1] += velocities[i+1];
                    if(positions[i+1] < -25) {
                        positions[i] = (Math.random() - 0.5) * 100;
                        positions[i+1] = 25;
                        positions[i+2] = (Math.random() - 0.5) * 100;
                    }
                }
                weatherParticles.geometry.attributes.position.needsUpdate = true;
            }

            const pos = playerGroup.position;
            document.getElementById('coords').textContent = `X: ${pos.x.toFixed(2)}, Y: ${pos.y.toFixed(2)}, Z: ${pos.z.toFixed(2)}`;
            const speedKmh = currentSpeedMs * 3.6;
            document.getElementById('speed-display').textContent = `${speedKmh.toFixed(0)} km/h | ${currentSpeedMs.toFixed(1)} m/s`;
            if (isAutoDriving) updateDestinationInfo();
            drawMap();

            composer.render();
            labelRenderer.render(scene, currentCamera);
            stats.end();
        }

        init();
    </script>
</body>
</html>
